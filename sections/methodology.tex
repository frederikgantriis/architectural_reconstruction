\section{Methodology}

To reconstruct the architecture of the Zeeguu API, I followed the Symphony-inspired process outlined in the course, which separates the reconstruction into distinct stages: data gathering, knowledge inference, and information interpretation. The focus was on reverse engineering architectural views from source code and version history without relying on existing documentation.

\subsection{Data Gathering}

I extracted structural and evolutionary data from the codebase using a combination of static code analysis and version control mining:

\begin{itemize}
  \item \textbf{Static analysis (AST)}: I used Pythonâ€™s built-in \texttt{ast} module to parse all \texttt{.py} files. This allowed me to extract:
  \begin{itemize}
    \item Class definitions
    \item Inheritance relationships
    \item Simple usage patterns (e.g., instantiations of one class inside another)
  \end{itemize}
  
  \item \textbf{Git churn analysis}: I analyzed the commit history with \texttt{git log} to count how many times each file was modified. This metric served as a proxy for volatility and was used to identify unstable or frequently maintained parts of the system.
\end{itemize}

\subsection{Knowledge Inference}

The raw data was processed into actionable insights by calculating key software metrics:

\begin{itemize}
  \item \textbf{Lines of Code (LOC)}: Counted per class and module, excluding comments and blank lines.
  \item \textbf{Churn}: Number of commits affecting each file.
  \item \textbf{Importance score}: For some views, classes were ranked by the combined score of LOC + churn, emphasizing both size and activity.
\end{itemize}

These metrics were used to filter and focus the views on the most relevant parts of the system.

\subsection{Visualization}

I created two main architectural visualizations:

\begin{itemize}
  \item \textbf{Class-level interactive view}: This view displays classes as nodes and their inheritance and usage relationships as edges. Node size is proportional to LOC, and node color is scaled by churn. It was implemented using \texttt{networkx} and \texttt{plotly}, resulting in an interactive HTML diagram.

  \item \textbf{Simplified module view}: Based on the top 15 most important classes (by LOC + churn), this view groups them by file and shows import dependencies between those files. It was implemented using Graphviz and exported as a \texttt{.dot} file for visual rendering. This view provides a high-level overview of how the system is organized into source files and how these files depend on one another.
\end{itemize}
